<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Tree Indices | Sanjay&#39;s Blog</title>
<meta name="keywords" content="learn, database, databases">
<meta name="description" content="Indexes in DBMS Indexes are very similar to the index section of a book. In books, indexes tell us where a word has been used and provide the page numbers. Just like that, indexes in a Database Management System (DBMS) tell us on what page or block a particular record is present.
So why do we need indexes?
Indexes save us a lot of time. Instead of searching from the start to the end of the book for a specific word, we can simply look up the index and go to the specific pages.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/tree-indices/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.1535157a41060cc8637b6c13233ea1e1b90cc098f9600d7bdfa1c6ea2fcb6f80.css" integrity="sha256-FTUVekEGDMhje2wTIz6h4bkMwJj5YA1736HG6i/Lb4A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.webp">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/tree-indices/">

<script>
    console.log("differe head is being loaded")
</script>
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Sanjay&#39;s Blog (Alt + H)">Sanjay&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Tree Indices
    </h1>
    <div class="post-meta"><span title='2024-06-17 00:00:00 +0000 UTC'>June 17, 2024</span>&nbsp;·&nbsp;15 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#indexes-in-dbms" aria-label="Indexes in DBMS">Indexes in DBMS</a><ul>
                        <ul>
                        
                <li>
                    <a href="#types-of-indices" aria-label="Types of Indices">Types of Indices</a></li></ul>
                    
                <li>
                    <a href="#ordered-indices" aria-label="Ordered Indices">Ordered Indices</a><ul>
                        
                <li>
                    <a href="#dense-index" aria-label="Dense Index">Dense Index</a></li>
                <li>
                    <a href="#sparse-index" aria-label="Sparse Index">Sparse Index</a></li>
                <li>
                    <a href="#multilevel-indices" aria-label="Multilevel indices">Multilevel indices</a></li></ul>
                </li>
                <li>
                    <a href="#insertion" aria-label="Insertion">Insertion</a></li>
                <li>
                    <a href="#dense-index-1" aria-label="Dense Index">Dense Index</a></li>
                <li>
                    <a href="#sparse-index-1" aria-label="Sparse Index">Sparse Index</a></li>
                <li>
                    <a href="#deletion" aria-label="Deletion">Deletion</a></li>
                <li>
                    <a href="#dense-index-2" aria-label="Dense Index">Dense Index</a></li>
                <li>
                    <a href="#sparse-index-2" aria-label="Sparse Index">Sparse Index</a></li>
                <li>
                    <a href="#secondary-indices-non-clustered-indices" aria-label="Secondary Indices (Non-Clustered Indices)">Secondary Indices (Non-Clustered Indices)</a><ul>
                        
                <li>
                    <a href="#non-unique-search-keys" aria-label="Non unique search keys">Non unique search keys</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#b-trees" aria-label="B&#43; Trees">B+ Trees</a><ul>
                        
                <li>
                    <a href="#m-way-search-tree" aria-label="M-way Search Tree">M-way Search Tree</a></li>
                <li>
                    <a href="#b-tree-structure" aria-label="B&#43; Tree Structure">B+ Tree Structure</a></li>
                <li>
                    <a href="#insertion-1" aria-label="Insertion">Insertion</a></li>
                <li>
                    <a href="#deletion-1" aria-label="Deletion">Deletion</a></li>
                <li>
                    <a href="#design-choices" aria-label="Design Choices">Design Choices</a><ul>
                        
                <li>
                    <a href="#node-size" aria-label="Node Size">Node Size</a></li>
                <li>
                    <a href="#merge-threshold" aria-label="Merge Threshold">Merge Threshold</a></li>
                <li>
                    <a href="#variable-length-keys" aria-label="Variable Length Keys">Variable Length Keys</a></li>
                <li>
                    <a href="#pointer" aria-label="Pointer">Pointer</a></li>
                <li>
                    <a href="#variable-length-nodes" aria-label="Variable Length Nodes">Variable Length Nodes</a></li>
                <li>
                    <a href="#padding" aria-label="Padding">Padding</a></li>
                <li>
                    <a href="#key-mapindirection" aria-label="Key Map/Indirection">Key Map/Indirection</a></li></ul>
                </li>
                <li>
                    <a href="#intra-node-search" aria-label="Intra-Node Search">Intra-Node Search</a><ul>
                        
                <li>
                    <a href="#linear-search" aria-label="Linear Search">Linear Search</a></li>
                <li>
                    <a href="#binary-search" aria-label="Binary Search">Binary Search</a></li></ul>
                </li>
                <li>
                    <a href="#optimization" aria-label="Optimization">Optimization</a><ul>
                        
                <li>
                    <a href="#prefix-compression" aria-label="Prefix Compression">Prefix Compression</a></li>
                <li>
                    <a href="#deduplication" aria-label="Deduplication">Deduplication</a></li>
                <li>
                    <a href="#bulk-insert" aria-label="Bulk Insert">Bulk Insert</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="indexes-in-dbms">Indexes in DBMS<a hidden class="anchor" aria-hidden="true" href="#indexes-in-dbms">#</a></h1>
<p>Indexes are very similar to the index section of a book. In books, indexes tell us where a word has been used and provide the page numbers. Just like that, indexes in a Database Management System (DBMS) tell us on what page or block a particular record is present.</p>
<p><strong>So why do we need indexes?</strong></p>
<p>Indexes save us a lot of time. Instead of searching from the start to the end of the book for a specific word, we can simply look up the index and go to the specific pages. Likewise, in DBMS, if we want to retrieve a specific record, instead of searching every record in the database, we can just go to the specific page or block and retrieve the record.</p>
<h3 id="types-of-indices">Types of Indices<a hidden class="anchor" aria-hidden="true" href="#types-of-indices">#</a></h3>
<ul>
<li><strong>Ordered indices:</strong> In ordered indices, the index is based on the sorted order of values.</li>
<li><strong>Hash indices:</strong> In hash indices, the values in the index are distributed over a range of buckets, and the value is hashed to get its index entry and then retrieve the location where the value is stored.</li>
</ul>
<h2 id="ordered-indices">Ordered Indices<a hidden class="anchor" aria-hidden="true" href="#ordered-indices">#</a></h2>
<p><strong>Clustering index:</strong> A clustering index is an index where the order in which the values are sorted in the index is the same as the order in which the values are stored in physical memory. Clustering indices reduce random access and are good for sequential access of records. They are also known as primary indices.</p>
<p><strong>Non-Clustering index:</strong> A non-clustering index is an index where the sort order on which the index is based is different from the order in which the values are stored in memory. If we want to access values over a range using non-clustering indices, there will be more random access. They are also known as secondary indices.</p>
<p><strong>Index sequential files:</strong> files where the records are stored in a sorted order, and they also have an index based on the value on which they are sorted.</p>
<p><strong>index entry:</strong> The search key value together with a pointer to the actual record in memory is known as an index entry.</p>
<h3 id="dense-index">Dense Index<a hidden class="anchor" aria-hidden="true" href="#dense-index">#</a></h3>
<p>A dense index is an index where there is an index entry for every record present. In case of duplicate search keys, only a pointer to the first record having that search key is stored, and the rest of the records can be found by a simple sequential access as the index is a clustered index.</p>
<p>Dense indices can also be used on non-clustered indices, but the duplicate keys should be handled differently.</p>
<p>Lookups are performed by just traversing the index table, and if it&rsquo;s based on a clustered index, we can use some optimization such as binary search.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/Dense_indices.png" alt="Dense indices"  />
</p>
<p>Dense indices</p>
<h3 id="sparse-index">Sparse Index<a hidden class="anchor" aria-hidden="true" href="#sparse-index">#</a></h3>
<p>A sparse index is an index where an index entry is present only for a few records. The size of a sparse index is smaller compared to a dense index. Sparse indices always need a clustering index as the lookup of the records which are not in the sparse index is not possible if it&rsquo;s not a clustering index.</p>
<p>Lookups are performed by finding an index entry whose search key value is the greatest search key value present in the sparse index which is less than or equal to the search key value we need, and then doing a sequential search from that record.</p>
<p><strong>Example:</strong> If the search key value is 55, we aim to find an index entry in the sparse index that&rsquo;s less than or equal to 55. If the sparse index contains entries like 45, 23, 25, and 35, we select 45. From there, we navigate to the record containing 45 and start a sequential search.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/sparse_indicies.png" alt="Sparse indices"  />
</p>
<p>Sparse indices</p>
<h3 id="multilevel-indices"><strong>Multilevel indices</strong><a hidden class="anchor" aria-hidden="true" href="#multilevel-indices">#</a></h3>
<p>When an index grows too large to fit in memory, searching for an index entry can become time-consuming due to increased disk I/O operations. To solve this issue, we use multilevel indices.</p>
<p>In a multilevel index, the large index table is divided into smaller sub-indices, also known as inner indices. A new index table, often called the outer index or root index, is created, where each index entry points to a specific sub-index of the original large index table. This allows for faster lookup of the relevant sub-index, enabling quicker search for the desired index entry.</p>
<h2 id="insertion"><strong>Insertion</strong><a hidden class="anchor" aria-hidden="true" href="#insertion">#</a></h2>
<h2 id="dense-index-1"><strong>Dense Index</strong><a hidden class="anchor" aria-hidden="true" href="#dense-index-1">#</a></h2>
<p>In a dense index, if a new record is added to the database, it is appropriately placed in physical memory, and then a new index entry is made into the dense index, which points to the record.</p>
<p>If the dense index stores pointers to all the records having the same search key, under one search key, then a new pointer to the record is just added at the end.</p>
<p>Given that the index is a clustering index, If the dense index is storing only a pointer to the first record having the same search key value, then it&rsquo;s not modified. If there is no index entry having the search key of the record being inserted, we create a new index entry.</p>
<h2 id="sparse-index-1"><strong>Sparse Index</strong><a hidden class="anchor" aria-hidden="true" href="#sparse-index-1">#</a></h2>
<p>If we assume an search key entry in a sparse index points to a block of records, and the index is a clustering index, then if a record is being inserted, it is checked if the new record holds the smallest value of the search key in that block. If it is, then we replace the old index entry with the new index entry, which points to the physical location of the newly inserted record. If not, it is not modified.</p>
<h2 id="deletion"><strong>Deletion</strong><a hidden class="anchor" aria-hidden="true" href="#deletion">#</a></h2>
<p>Whenever a record is deleted from a relation, it should be removed from all the indices associated with that relation, so that we can avoid inconsistencies in query results.</p>
<h2 id="dense-index-2"><strong>Dense Index</strong><a hidden class="anchor" aria-hidden="true" href="#dense-index-2">#</a></h2>
<p>If a record is being deleted, first the search key value associated with that record is found, and then removed from the index.</p>
<p>If the dense index is storing all the pointers to the records having the same search key value, then the pointer to the record being deleted is removed.</p>
<p>If the dense index is storing only a pointer to the first record having the same search key value, then it is checked if the record being deleted is the first record. If it is, then the index entry is made to point to the next record having the same search key value.</p>
<h2 id="sparse-index-2"><strong>Sparse Index</strong><a hidden class="anchor" aria-hidden="true" href="#sparse-index-2">#</a></h2>
<p>It is checked if there is an entry of the record in the sparse index. If so, then the index entry is made to point to the next smallest value in that block. If not, the sparse index is not modified.</p>
<h2 id="secondary-indices-non-clustered-indices"><strong>Secondary Indices (Non-Clustered Indices)</strong><a hidden class="anchor" aria-hidden="true" href="#secondary-indices-non-clustered-indices">#</a></h2>
<p>Secondary indices are also known as non-clustered indices. Here, the search key on which the index is constructed upon is different from the search key that the records are sorted and stored in memory.</p>
<p>Here, the construction of a sparse index is not possible, but the construction of a dense index is possible. Even though the construction of a dense index is possible, the physical location of the values pointed by search keys might be stored in a different order.</p>
<p>To increase the access time, the search keys are first found, and then sorted based on their physical location, and then accessed.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/Non_clustering_index.png" alt="Non-Clustering index"  />
</p>
<p>Non-Clustering index</p>
<h3 id="non-unique-search-keys">Non unique search keys<a hidden class="anchor" aria-hidden="true" href="#non-unique-search-keys">#</a></h3>
<p>If the search keys are non-unique, that is, whenever they are not based on primary keys, then the DBMS will generally concatenate the primary key to create a composite key of the non-unique search key to make it unique and then store it.</p>
<p><strong>Non-Unique Indices</strong>: These are the indices that allow the storage of non-unique search keys.</p>
<h1 id="b-trees">B+ Trees<a hidden class="anchor" aria-hidden="true" href="#b-trees">#</a></h1>
<p>The performance of indexes discussed earlier will degrade as the database size increases. However, B+ Tree data structures provide a consistent $O(log(n))$ time complexity for both insertions and deletions. The &ldquo;B&rdquo; in B+ Tree is not formally defined but is generally referred to as &ldquo;balanced.”</p>
<p>B+ Tree is like a evolution of M-way search tree</p>
<h2 id="m-way-search-tree">M-way Search Tree<a hidden class="anchor" aria-hidden="true" href="#m-way-search-tree">#</a></h2>
<p>An M-way search tree is an evolution of a binary search tree. In a binary search tree, each parent node has two child nodes: the left child and the right child. The value stored in the left child is less than the value of its parent node, and the value stored in the right child is greater than the value of its parent node.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/binary_search_tree.png" alt="Binary Search Tree"  />
</p>
<p>Binary Search Tree</p>
<p>In m-way search trees, the structure of the node is a bit different. Here, each node can store multiple values. An m-way search tree of order n has n pointers to child nodes and has n - 1 values.</p>
<p>Let&rsquo;s say a node of order n has pointers, p1, p2, ….., pn. and n - 1 values, say v1, v2, v3, … vn-1. The pointer p1 is present at the left end and pointer pn is present at the right end.</p>
<p>The values stored in the child node pointed by pointer p1 will be less than the value v1, and the values stored in the child node pointed by the pointer pn will be greater than the value vn-1. Let&rsquo;s say pointer pa is present between values va-1 and va. Here, the child node pointed by the pointer pa stores the values that are less than value va and greater than the value va-1.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/M_way_node_structure.png" alt="M way node structure"  />
</p>
<p>M way node structure</p>
<p>Here is an example of an M-way search tree of order 4:</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/M_way_search_tree_example.png" alt="M-way search tree example"  />
</p>
<p>M-way search tree example</p>
<h2 id="b-tree-structure"><strong>B+ Tree Structure</strong><a hidden class="anchor" aria-hidden="true" href="#b-tree-structure">#</a></h2>
<p>A B+ Tree is a special type of M-way tree with some additional rules:</p>
<ul>
<li>every leaf node is of equal depth from the root node</li>
<li>every inner node apart from root node is at least half full, that is number of pointers in a node is always greater then or equal to $⌈(n − 1)∕2⌉$</li>
<li>every inner node with k keys has k+1 non null children</li>
</ul>
<p>In a B+ Tree, the data that is a pointer to a record or the actual contents of the record are only stored in the leaf nodes. Here is the general structure of a B+ Tree:</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/B_tree_structure.png" alt="B-tree structure"  />
</p>
<p>B-tree structure</p>
<p>The structure of non-leaf nodes is different from leaf nodes. Pointers in non-leaf nodes store a pointer to another non-leaf node or a leaf node.</p>
<p>In a leaf node, the value stored may be a pointer to the record containing the search key value or the actual contents of the record.</p>
<p>Here is the general structure of a leaf node. The last pointer of the node points to the next leaf node.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/Leaf_node.png" alt="Leaf Node "  />
</p>
<p>Leaf Node</p>
<h2 id="insertion-1">Insertion<a hidden class="anchor" aria-hidden="true" href="#insertion-1">#</a></h2>
<p>Inserting an index is straightforward if there is enough space in the leaf nodes. If we assume there is enough space in the leaf node, we simply find the node where we should add the new entry and add it.</p>
<p>Insertion becomes more complex when there is not enough space in the leaf nodes, and the leaf node must be split. Here is an example of insertion:</p>
<p>If we want to insert an index entry and there is not enough space in the leaf node, the leaf node is split into two nodes. The first ⌈n/2⌉ values stay in the left node, and the rest of the values are moved to the new node. Now, the parent node is updated to include a pointer to the new node.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/insertion-1.png" alt="insertion-1"  />
</p>
<p>insertion-1</p>
<p>If there is not enough space in the parent node to accommodate the new left node created, we split the parent node. We first assume that there is enough space in the parent node by conceptually extending it. Then, we split the node, and the search key value that is present between the pointers that are kept in the left node and the pointers that are moved to the right node is moved up to its parent node.</p>
<p>In the example below, it&rsquo;s 46. Here, there is no parent node, so we create a new parent node and add the search key value 46 to it. The new node becomes the root node and also increases the depth of the tree.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/insertion-2.png" alt="insertion-2"  />
</p>
<p>insertion-2</p>
<h2 id="deletion-1">Deletion<a hidden class="anchor" aria-hidden="true" href="#deletion-1">#</a></h2>
<p>Deletion in B+ trees is a more complex process than insertion. If deleting an index entry does not violate the rule of the node being at least half full, no changes are needed, and we can simply remove the index entry from the leaf node.</p>
<p>However, if the leaf node has fewer pointers than the minimum required, i.e., $n&rsquo; &lt; ⌈(n − 1)∕2⌉$, where n&rsquo; is the number of pointers present in the current node and n is the order of the B+ tree, then the leaf nodes must be merged or pointers in the leaf node must be redistributed.</p>
<p>In the example below, we first delete the record 45. Now, the leaf node is left with only one pointer, which points to the search key value containing 40. Since there is enough space in the sibling node, the pointer in the right leaf node can be merged with the left leaf node, and the empty node is deleted, along with the search key in the parent node.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-1.png" alt="Deletion-1"  />
</p>
<p>Deletion-1</p>
<p>here is the final state of the B+ tree</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-2.png" alt="Deletion-2"  />
</p>
<p>Deletion-2</p>
<p>Now, let&rsquo;s see an example where we need to merge parent nodes.
Assume the below B+ tree, and delete the search key 60.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-3.png" alt="Deletion-3"  />
</p>
<p>Deletion-3</p>
<p>Here, the search key 60 is first deleted, then the leaf node containing it becomes underfull (it is not half-full). Since the sibling node has enough space to accommodate the remaining pointers, the search key 50 is merged with its sibling, and the search key 60 is removed from its parent node, and the empty node is deleted.</p>
<p>Now, the parent node is underfull, and we cannot merge the pointers with the sibling node as the sibling node of the parent node is full (30, 40, 43). Here, we redistribute the pointers, moving the rightmost pointer of the sibling node to the right node.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-4.png" alt="Deletion-4"  />
</p>
<p>Deletion-4</p>
<p>As the pointers are redistributed, the pointer that separates these two pointers is not present in both nodes, but the search key value is present in the parent node, currently separating them, which is 46.</p>
<p>Here, the parent node, i.e., the root node, should also be updated to have the correct search key value. The search key value from the sibling node is moved up.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-5.png" alt="Deletion-5"  />
</p>
<p>Deletion-5</p>
<p>Here is the final state of the B+ tree structure:</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-6.png" alt="Deletion-6"  />
</p>
<p>Deletion-6</p>
<p>Sometimes, deletion can reduce the size of the B+ tree.
Now, assume the below B-tree:</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-7.png" alt="Deletion-7"  />
</p>
<p>Deletion-7</p>
<p>Now, if we delete the search key entry 47,</p>
<p>deletion of 47 from the leaf node makes it underfull. Now, the leaf node cannot be merged with the sibling node, so we redistribute the search keys. The rightmost search key 45 is moved left.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-8.png" alt="Deletion-8"  />
</p>
<p>Deletion-8</p>
<p>Here, the 46 in the parent node no longer separates the two child nodes, so we correct it by changing it to 45.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-9.png" alt="Deletion-9"  />
</p>
<p>Deletion-9</p>
<p>Now, we delete 46.</p>
<p>If we delete 46, the index entry 45 can now be merged with its sibling node, and the empty right node is deleted.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-10.png" alt="Deletion-10"  />
</p>
<p>Deletion-10</p>
<p>Now, the parent node is underflowing, and it can now also be merged with its sibling. The search key value separating them is the value present in their parent&rsquo;s node, which is 43.</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-11.png" alt="Deletion-11"  />
</p>
<p>Deletion-11</p>
<p>Now, the root node has only one pointer in it, so the root node is now deleted, and the depth of the entire B+ tree is now reduced.</p>
<p>Here is the final state of the B+ tree:</p>
<p><img loading="lazy" src="/images/2024-6-17-Tree-indices/deletion-12.png" alt="Deletion-12"  />
</p>
<p>Deletion-12</p>
<h2 id="design-choices">Design Choices<a hidden class="anchor" aria-hidden="true" href="#design-choices">#</a></h2>
<h3 id="node-size">Node Size<a hidden class="anchor" aria-hidden="true" href="#node-size">#</a></h3>
<p>Generally, large node sizes are preferred over smaller ones, as the larger node size reduces the number of hard-disk access times, which can speed up the process. Typically, the size of each node is the same as the size of a single hard-disk page or block.</p>
<h3 id="merge-threshold">Merge Threshold<a hidden class="anchor" aria-hidden="true" href="#merge-threshold">#</a></h3>
<p>Sometimes, merging of nodes is not carried out in OLTP databases because the number of insertions and deletions is so high that the overhead caused by merging nodes can be significant. The CPU will spend more time merging nodes than actually performing insertions and deletions. This is also known as thrashing.</p>
<h3 id="variable-length-keys">Variable Length Keys<a hidden class="anchor" aria-hidden="true" href="#variable-length-keys">#</a></h3>
<p>Sometimes, the length of the search key can vary, for example, if the search key is a name of different lengths.</p>
<h3 id="pointer">Pointer<a hidden class="anchor" aria-hidden="true" href="#pointer">#</a></h3>
<p>Here, a pointer to the search key value is stored instead of storing the search key value directly.</p>
<h3 id="variable-length-nodes">Variable Length Nodes<a hidden class="anchor" aria-hidden="true" href="#variable-length-nodes">#</a></h3>
<p>The search keys are stored normally, but the length of the node can change. This method is not generally used due to the large overhead in managing it.</p>
<h3 id="padding">Padding<a hidden class="anchor" aria-hidden="true" href="#padding">#</a></h3>
<p>The size of the search key is fixed, but for the search keys whose length is less, padding is added to make it fit in. This method is also not generally used due to the memory wastage in padding.</p>
<h3 id="key-mapindirection">Key Map/Indirection<a hidden class="anchor" aria-hidden="true" href="#key-mapindirection">#</a></h3>
<p>This is the most commonly used method. The structure of the node is similar to the slotted page, where we have metadata storing some information about the node. We then have an array of pointers pointing to the search key values in the node.</p>
<h2 id="intra-node-search">Intra-Node Search<a hidden class="anchor" aria-hidden="true" href="#intra-node-search">#</a></h2>
<p>The size of the node in B+trees is generally large, so we also need to use optimised search algorithms to find the required search key in the node.</p>
<p>Here are some techniques used to search for the required search key:</p>
<h3 id="linear-search">Linear Search<a hidden class="anchor" aria-hidden="true" href="#linear-search">#</a></h3>
<p>Every search key in the node is traversed to check if it is the one that is required. The time complexity is $O(n)$.</p>
<h3 id="binary-search">Binary Search<a hidden class="anchor" aria-hidden="true" href="#binary-search">#</a></h3>
<p>The binary search technique is used to find the required search key.</p>
<p>$O(log (n))$</p>
<h2 id="optimization">Optimization<a hidden class="anchor" aria-hidden="true" href="#optimization">#</a></h2>
<h3 id="prefix-compression">Prefix Compression<a hidden class="anchor" aria-hidden="true" href="#prefix-compression">#</a></h3>
<p>Most search key values stored in a single node are likely to have a part in common. For example: 10001, 10006, 10009. Here, the search keys have 1000 in common. Therefore, only 1000 can be stored, and then 1, 6, 9 can be stored separately, hence saving some space.</p>
<h3 id="deduplication">Deduplication<a hidden class="anchor" aria-hidden="true" href="#deduplication">#</a></h3>
<p>Sometimes, the indexes support the insertion of duplicate values. Generally, a primary key is attached at the end to make it a unique composite key. Here, the duplicate search key can only be stored once, and the records can in turn be differentiated by only the primary key, which saves the space lost in storing the duplicate key multiple times.</p>
<h3 id="bulk-insert">Bulk Insert<a hidden class="anchor" aria-hidden="true" href="#bulk-insert">#</a></h3>
<p>Sometimes, if we want to create a new B+tree for a relation, then if we insert the search key of each record one by one, it would lead to a lot of splits and would be slow. Instead, we first get all the search keys and their values, sort them, then turn them into leaf nodes and build the B+ tree from the bottom up.</p>
<p>here is the B+tree <a href="/images/2024-6-17-Tree-indices/b-tree-insertion-deletion.pdf">insertion and deletion</a> example pdf</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/learn/">Learn</a></li>
      <li><a href="http://localhost:1313/tags/database/">Database</a></li>
      <li><a href="http://localhost:1313/tags/databases/">Databases</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/index-concurrency/">
    <span class="title">« Prev</span>
    <br>
    <span>Index Concurrency</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/buffer-pool-manager-and-hashing/">
    <span class="title">Next »</span>
    <br>
    <span>Buffer Pool and Hashing</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Tree Indices on x"
            href="https://x.com/intent/tweet/?text=Tree%20Indices&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2ftree-indices%2f&amp;hashtags=learn%2cdatabase%2cdatabases">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Tree Indices on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2ftree-indices%2f&amp;title=Tree%20Indices&amp;summary=Tree%20Indices&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2ftree-indices%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Tree Indices on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2ftree-indices%2f&title=Tree%20Indices">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Tree Indices on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2ftree-indices%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Tree Indices on whatsapp"
            href="https://api.whatsapp.com/send?text=Tree%20Indices%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2ftree-indices%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Tree Indices on telegram"
            href="https://telegram.me/share/url?text=Tree%20Indices&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2ftree-indices%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Tree Indices on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Tree%20Indices&u=http%3a%2f%2flocalhost%3a1313%2fposts%2ftree-indices%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Sanjay&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
